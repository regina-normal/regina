diff --git a/python/pybind11_v3/pybind11/pybind11.h b/python/pybind11_v3/pybind11/pybind11.h
index e747e274d..8f23dc60c 100644
--- a/python/pybind11_v3/pybind11/pybind11.h
+++ b/python/pybind11_v3/pybind11/pybind11.h
@@ -33,6 +33,10 @@
 #include <utility>
 #include <vector>
 
+// This allows us to verify that we are #including our own patched pybind11,
+// not some other pybind11 that has been installed system-wide.
+#define REGINA_PYBIND11 1
+
 // See PR #5448. This warning suppression is needed for the PYBIND11_OVERRIDE macro family.
 // NOTE that this is NOT embedded in a push/pop pair because that is very difficult to achieve.
 #if defined(__clang_major__) && __clang_major__ < 14
@@ -43,6 +47,10 @@ PYBIND11_WARNING_DISABLE_CLANG("-Wgnu-zero-variadic-macro-arguments")
 #    include <cxxabi.h>
 #endif
 
+namespace regina {
+    const char* pythonTypename(const std::type_info*);
+}
+
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 
 /* https://stackoverflow.com/questions/46798456/handling-gccs-noexcept-type-warning
@@ -157,18 +165,52 @@ inline std::string generate_function_signature(const char *type_caster_name_fiel
             if (!t) {
                 pybind11_fail("Internal error while parsing type signature (1)");
             }
-            if (auto *tinfo = detail::get_type_info(*t)) {
+            if (const char* name = regina::pythonTypename(t)) {
+                signature += name;
+            } else if (auto *tinfo = detail::get_type_info(*t)) {
                 handle th((PyObject *) tinfo->type);
-                signature += th.attr("__module__").cast<std::string>() + "."
-                             + th.attr("__qualname__").cast<std::string>();
+                std::string qualname;
+                try {
+                    qualname = th.attr("__qualname__").cast<std::string>();
+                } catch (...) {
+                    // In Python 3.12 we get an error in our stripped-down
+                    // interpreter since PythonOutputStream is missing both
+                    // __qualname__ and __name__.  Do not make this fatal.
+                    qualname = "<unknown>";
+                }
+                const auto m = th.attr("__module__").cast<std::string>();
+                if (m == "regina.engine")
+                    signature += "regina." + qualname;
+                else
+                    signature += m + "." + qualname;
             } else if (auto th = detail::global_internals_native_enum_type_map_get_item(*t)) {
-                signature += th.attr("__module__").cast<std::string>() + "."
-                             + th.attr("__qualname__").cast<std::string>();
+                std::string qualname;
+                try {
+                    qualname = th.attr("__qualname__").cast<std::string>();
+                } catch (...) {
+                    // See above for the explanation here.
+                    qualname = "<unknown>";
+                }
+                const auto m = th.attr("__module__").cast<std::string>();
+                if (m == "regina.engine")
+                    signature += "regina." + qualname;
+                else
+                    signature += m + "." + qualname;
             } else if (func_rec->is_new_style_constructor && arg_index == 0) {
                 // A new-style `__init__` takes `self` as `value_and_holder`.
                 // Rewrite it to the proper class type.
-                signature += func_rec->scope.attr("__module__").cast<std::string>() + "."
-                             + func_rec->scope.attr("__qualname__").cast<std::string>();
+                std::string qualname;
+                try {
+                    qualname = func_rec->scope.attr("__qualname__").cast<std::string>();
+                } catch (...) {
+                    // See above for the explanation here.
+                    qualname = "<unknown>";
+                }
+                const auto m = func_rec->scope.attr("__module__").cast<std::string>();
+                if (m == "regina.engine")
+                    signature += "regina." + qualname;
+                else
+                    signature += m + "." + qualname;
             } else {
                 signature += detail::quote_cpp_type_name(detail::clean_type_id(t->name()));
             }
@@ -1110,6 +1152,16 @@ protected:
         } catch (abi::__forced_unwind &) {
             throw;
 #endif
+        } catch (const pybind11::stop_iteration& stop) {
+            /* We prioritise catching stop_iteration before any of the other
+               exception logic below, since stop_iteration is arguably the one
+               setting where exceptions are normal as opposed to "exceptional".
+               The default exception logic involves many try/catch/rethrow
+               blocks, and in settings where try/catch is slow (e.g., running
+               within SageMath on macOS), this can add to a noticeable
+               performance penalty when using iterators. */
+            PyErr_SetString(PyExc_StopIteration, stop.what());
+            return nullptr;
         } catch (...) {
             try_translate_exceptions();
             return nullptr;
diff --git a/python/pybind11_v3/pybind11/subinterpreter.h b/python/pybind11_v3/pybind11/subinterpreter.h
index 9f2f704c5..cb666cf28 100644
--- a/python/pybind11_v3/pybind11/subinterpreter.h
+++ b/python/pybind11_v3/pybind11/subinterpreter.h
@@ -21,7 +21,7 @@
 
 PYBIND11_NAMESPACE_BEGIN(PYBIND11_NAMESPACE)
 PYBIND11_NAMESPACE_BEGIN(detail)
-PyInterpreterState *get_interpreter_state_unchecked() {
+inline PyInterpreterState *get_interpreter_state_unchecked() {
     auto cur_tstate = get_thread_state_unchecked();
     if (cur_tstate)
         return cur_tstate->interp;
